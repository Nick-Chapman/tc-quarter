27 tests ran; all pass.
*tc-quarter*
quarter.q
?' :: (s -- s.&(S? -- S?))
?~ :: (s -- s)
?# :: (s.x1 -- s)
?i :: (s -- s.&c1)
?t :: (s.&Num -- s)
( :: (s -- s)
?( :: (s -- s)
?h :: (s -- s.&c1)
?j :: (s -- s)
?q :: (s.&Char.&Char -- s.Num)
?p :: (s.&Char -- s)
?n :: (s.Num -- s.Num)
?k :: (s -- s)
?c :: (s -- s)
?v :: (s -- s.&c1)
?w :: (s -- s.&c1)
?g :: (s.&Char.&(s1 -- s2) -- s.&(s1 -- s2))
?u :: (s.&Char -- s.&(S? -- S?))
?f :: (s.&Char -- s.&(S? -- S?))
[ :: (S? -- S?)
?[ :: (S? -- S?)
?] :: (S? -- S?)
: :: (s -- s1)
' :: (s -- s.&(S? -- S?))
immediate :: (s -- s)
here :: (s -- s.&c1)
literal :: (s.x1 -- s)
[compile] :: (s -- s)
['] :: (s -- s)
compile :: (s -- s)
tail :: (s -- s)
recurse :: (s -- s)
ahead> :: (s -- s.&c1)
<patch :: (s.&Num -- s)
if :: (s -- s.&c1)
then :: (s.&Num -- s)
else :: (s.&Num -- s.&Num)
begin :: (s -- s.&c1)
again :: (s.&c1 -- s)
bl :: (s -- s.Num)
is-white :: (s.Num -- s.Num)
skip-leading-whitespace :: (s -- s)
collect-while-not-whitespace :: (s -- s)
word, :: (s -- s.&c1)
word :: (s -- s.&c1)
char :: (s -- s.Num)
[char] :: (s -- s)
skip-to-close :: (s.Num -- s)
( :: (s -- s)
2 :: (s -- s.Num)
3 :: (s -- s.Num)
constant :: (s.x1 -- s)
variable :: (s -- s)
type :: (s.&Char -- s)
collect-string :: (s -- s.Num)
s" :: (s -- s)
." :: (s -- s1)
abort" :: (s -- s1)
.." :: (s -- s1)
forth.f
space :: (s -- s)
rot :: (s.x1.x2.x3 -- s.x2.x4.x1)
-rot :: (s.x1.x2.x3 -- s.x3.x1.x4)
show-if-not-hidden :: (s.&(s1 -- s2) -- s)
rev-words-continue :: (s.x1.x1 -- s.x1.x1)
words-since :: (s.&(S? -- S?) -- s)
rev-words :: (s -- s)
words-continue :: (s.&(s1 -- s2) -- s)
words :: (s -- s)
x-hide :: (s.&(s1 -- s2) -- s)
hide :: (s -- s)
allot :: (s.Num -- s)
cell :: (s -- s.Num)
cells :: (s.Num -- s.Num)
cell+ :: (s.x1 -- s.x1)
char+ :: (s.x1 -- s.x1)
chars :: (s -- s)
space :: (s -- s)
spaces :: (s.Num -- s)
false :: (s -- s.x1)
true :: (s -- s.Num)
or :: (s.Num.x1 -- s.Num)
and :: (s.x1.x2 -- s.x1)
invert :: (s.Num -- s.Num)
nip :: (s.x1.x2 -- s.x2)
2dup :: (s.x1.x2 -- s.x1.x2.x1.x2)
2drop :: (s.x1.x2 -- s)
> :: (s.x1.x1 -- s.Num)
<= :: (s.x1.x1 -- s.Num)
>= :: (s.x1.x1 -- s.Num)
0< :: (s.x1 -- s.Num)
0= :: (s.x1 -- s.Num)
1+ :: (s.x1 -- s.x1)
1- :: (s.Num -- s.Num)
negate :: (s.x1 -- s.Num)
abs :: (s.Num -- s.Num)
min :: (s.x1.x1 -- s.x1)
max :: (s.x1.x1 -- s.x1)
mod :: (s.Num.Num -- s.Num)
/ :: (s.Num.Num -- s.Num)
+! :: (s.Num.&Num -- s)
2 :: (s -- s.Num)
10 :: (s -- s.Num)
16 :: (s -- s.Num)
256 :: (s -- s.Num)
akey? :: (s -- s.Num)
ekey? :: (s -- s.Num)
do :: (s -- s.&c1)
i :: (s -- s)
loop :: (s.&c1 -- s)
erase :: (s.&Char.Num -- s)
hex-mode :: (s -- s.&c2)
hex :: (s -- s)
decimal :: (s -- s)
decimal-digit? :: (s.Num -- s.Num)
extended-digit? :: (s.Num -- s.Num)
hex-digit? :: (s.Num -- s.Num)
digit? :: (s.Num -- s.Num)
convert-digit :: (s.Num -- s.Num)
base :: (s -- s.Num)
number-loop :: (s.Num.&Char -- s.Num.Num)
number? :: (s.&Char -- s.Num.Num)
print-digit :: (s.Num -- s)
dot-loop :: (s.Num -- s)
.decimal :: (s.Num -- s)
.hex1 :: (s.Num -- s)
.hex2 :: (s.Num -- s)
.hex4 :: (s.Num -- s)
.hex :: (s.Num -- s)
. :: (s.Num -- s)
? :: (s.&Num -- s)
s= :: (s.&Char.&Char -- s.Num)
find-loop :: (s.&Char.&(s1 -- s2) -- s.&(s1 -- s2))
find :: (s.&Char -- s.&(S? -- S?))
find! :: (s.&Char -- s.&(S? -- S?))
' :: (s -- s.&(S? -- S?))
compiling :: (S? -- S?)
: :: (S? -- S?)
** TypeError: ../quarter-forth/f/forth.f:461.9 (compose) : stack mismatch: S? ~ S?.Num
** TypeError: ../quarter-forth/f/forth.f:462.25 (branch0) : stack cyclic: s6057 ~ s6057.x6059
[ :: (S? -- S?)
x :: (s.Num.Num -- s)
Loading tools
mem :: (s -- s)
memv :: (s -- s)
e8 :: (s -- s.Num)
c3 :: (s -- s.Num)
is-call :: (s.Num -- s.Num)
is-ret :: (s.Num -- s.Num)
@rel->abs :: (s.&Num -- s.&Num)
** TypeError: ../quarter-forth/f/tools.f:33.4 (compose) : contents: Num ~ Char
** TypeError: ../quarter-forth/f/tools.f:38.6 (compose) : contents: Num ~ Char
** TypeError: ../quarter-forth/f/tools.f:34.20 (compose) : contents: Num ~ (s6683 -- s6684)
disassemble :: (s.&Num -- s)
** TypeError: ../quarter-forth/f/tools.f:51.4 (compose) : contents: (s6892 -- s6893) ~ Num
x-see :: (s.&(s1 -- s2) -- s)
** TypeError: ../quarter-forth/f/tools.f:57.18 (branch0) : stack cyclic: s6963.&(s6960 -- s6961) ~ s6963
see :: (s -- s)
** TypeError: ../quarter-forth/f/tools.f:63.0 (compose) : elem: Num ~ &Num
** TypeError: ../quarter-forth/f/tools.f:63.4 (compose) : elem: &Num ~ Num
** TypeError: ../quarter-forth/f/tools.f:63.8 (compose) : elem: Num ~ &Num
.s-continue :: (s.Num -- s)
** TypeError: ../quarter-forth/f/tools.f:71.4 (compose) : elem: &Num ~ Num
.s :: (s -- s)
depth :: (s -- s.Num)
rdepth :: (s -- s.Num)
.?stack :: (s -- s)
times :: (s.&(s -- s1).x2 -- s)
old-key :: (s -- s.&(s1 -- s1.Num))
raw-key :: (s -- s.Num)
is-escape :: (s.Num -- s.Num)
** TypeError: ../quarter-forth/f/tools.f:107.5 (compose) : elem cyclic: x7335 ~ &(s7334.x7335.x7336 -- s7331.x7407.x7400)
pag-continue :: (s.x2.x3 -- s1)
pag :: (s.x2.x3 -- s1)
is-printable? :: (s.Num -- s.Num)
emit-printable-or-dot :: (s.Num -- s)
** TypeError: ../quarter-forth/f/tools.f:124.7 (branch0) : stack cyclic: s7573.x7571 ~ s7573
drop-if-not-zero :: (s.x1 -- s)
default-0 :: (s -- s)
dc :: (s.&Char -- s.&Char)
dc64 :: (s.Num -- s.Num)
dc-oneK :: (s -- s)
dump :: (s.x2 -- s1)
emit-byte :: (s.Num -- s)
db :: (s.&Char -- s.&Char)
xxd-line :: (s.Num -- s.Num)
xxd-page :: (s -- s)
xxd :: (s.x2 -- s1)
see1 :: (s.&(S? -- S?) -- s.&(S? -- S?))
see10 :: (s -- s)
see-all :: (s -- s1)
Loading regression
inc :: (s.x1 -- s.x1)
hi :: (s -- s.Num.Num)
-1 :: (s -- s.Num)
eggs :: (s -- s.&c2)
e :: (s -- s)
sq :: (s -- s1)
a :: (s -- s.&c2)
b :: (s -- s.&c2)
one :: (s -- s.Num)
two :: (s -- s.Num)
life :: (s -- s.Num)
Loading examples ( star :: (s -- s)
stars :: (s.x1 -- s)
margin :: (s -- s)
blip :: (s -- s)
bar :: (s -- s)
F :: (s -- s)
square :: (s.Num -- s.Num)
fact :: (s.Num -- s.Num)
fib :: (s.Num -- s.Num)
fact-iterative :: (s.x1 -- s.Num)
even? :: (s.Num -- s.Num)
collatz :: (s.Num -- s)
z :: (s -- s)
twice :: (s.&(s -- s1) -- s2)
F fact fib fact-iterative collatz z )
Loading primes
divisible-by :: (s.Num.Num -- s.Num)
any-divide :: (s.x1.&Char -- s.Num)
primes-below-16 :: (s -- s.&c2)
is-small-prime :: (s.x1 -- s.Num)
small-loop :: (s.Num -- s)
primes-below-256 :: (s -- s.&c2)
is-big-prime :: (s.x1 -- s.Num)
big-loop :: (s.Num -- s)
emit-list :: (s.&Char -- s)
primes :: (s -- s)
Loading snake
set-block-cursor :: (s -- s)
set-underline-cursor :: (s -- s)
hide-cursor :: (s -- s)
at-xy :: (s.Num.Num -- s)
xy-read-char-col :: (s.Num.Num -- s.Num.Num)
xy-read-char :: (s.Num.Num -- s.Num)
xy-read-col :: (s.Num.Num -- s.Num)
fg :: (s -- s.&c2)
bg :: (s -- s.&c2)
colour :: (s -- s.Num)
xy-emit :: (s.Num.x1.Num -- s)
black :: (s -- s.Num)
blue :: (s -- s.Num)
green :: (s -- s.Num)
cyan :: (s -- s.Num)
red :: (s -- s.Num)
magenta :: (s -- s.Num)
brown :: (s -- s.Num)
light-grey :: (s -- s.Num)
dark-grey :: (s -- s.Num)
light-blue :: (s -- s.Num)
light-green :: (s -- s.Num)
light-cyan :: (s -- s.Num)
light-red :: (s -- s.Num)
light-magenta :: (s -- s.Num)
yellow :: (s -- s.Num)
white :: (s -- s.Num)
block :: (s.Num.x1 -- s)
block-right :: (s.Num.x1 -- s.Num.x1)
block-down :: (s.Num.x1 -- s.Num.x1)
border :: (s -- s)
max-len :: (s -- s.Num)
xta :: (s -- s.&c2)
yta :: (s -- s.&c2)
xpos :: (s.Num -- s.&c2)
ypos :: (s.Num -- s.&c2)
direction :: (s -- s.&c2)
going-vertical :: (s -- s.&c2)
escaped :: (s -- s.&c2)
slowness :: (s -- s.&c2)
len :: (s -- s.&c2)
-1 :: (s -- s.Num)
left :: (s -- s)
right :: (s -- s)
up :: (s -- s)
down :: (s -- s)
nop :: (s -- s)
set-start-state :: (s -- s)
move-head :: (s -- s1)
set-dir :: (s.x1 -- s)
isH :: (s -- s.Num)
isV :: (s -- s.x1)
setH :: (s -- s)
setV :: (s -- s)
shift-x :: (s.Num -- s)
shift-y :: (s.Num -- s)
shift-xy :: (s.Num -- s)
head-to-tail-loop :: (s.Num -- s)
head-to-tail :: (s -- s)
clear-tail :: (s -- s)
maybe-grow :: (s.Num -- s)
tick :: (s -- s)
tick2 :: (s -- s)
pause1 :: (s -- s)
do-pause :: (s -- s)
speed-up :: (s -- s)
is-escape :: (s.Num -- s.Num)
is-return :: (s.Num -- s.Num)
control :: (s.Num.Num -- s)
snake-char :: (s -- s.Num)
draw-head :: (s -- s)
collide? :: (s -- s.Num)
wait :: (s -- s)
app-loop :: (s -- s.Num)
snake :: (s -- s)
Loading buffer
old-key :: (s -- s.&(s1 -- s1.Num))
raw-key :: (s -- s.Num)
key-buffer-size :: (s -- s.Num)
key-buffer :: (s -- s.&c2)
at-start-of-buffer :: (s.&c2 -- s.Num)
is-space-left-in-buffer :: (s.&c2 -- s.Num)
is-newline :: (s.Num -- s.Num)
is-backspace :: (s.Num -- s.Num)
is-printable :: (s.Num -- s.Num)
**{EchoEnabled}
echo-enabled :: (s -- s.&c2)
**{EchoOff}
echo-on :: (s -- s)
echo-off :: (s -- s)
echo :: (s.Num -- s)
ok :: (s -- s)
-1 :: (s -- s.Num)
fill-loop :: (s.&Char -- s.&Char)
fill :: (s -- s)
kb-pointer :: (s -- s.&c2)
reset-kb-pointer :: (s -- s)
buffered-key :: (s -- s.Num)
**{SetKey}

Welcome to Quarter Forth. A 16-bit Forth system running on x86.

Bytes available: 55214 

** TypeError: ../quarter-forth/f/start.f:11.3 (compose) : contents: Num ~ Char
wipe :: (s.&Char -- s)
**{StartupIsComplete}
#machine-ticks=8499414
#errors=14
