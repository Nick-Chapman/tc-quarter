25 tests ran; all pass.
*tc-quarter*
quarter.q
?' :: (s -- s.&(s1 -- s2))
?~ :: (s -- s)
?# :: (s.x1 -- s)
?i :: (s -- s.&c1)
?t :: (s.&Num -- s)
( :: (s -- s)
?( :: (s -- s)
?h :: (s -- s.&c1)
?j :: (s -- s)
?q :: (s.&Char.&Char -- s.Num)
?p :: (s.&Char -- s)
?n :: (s.Num -- s.Num)
?k :: (s -- s)
?c :: (s -- s)
?v :: (s -- s.&c1)
?w :: (s -- s.&c1)
?g :: (s.&Char.&(s1 -- s2) -- s.&(s1 -- s2))
?u :: (s.&Char -- s.&(s1 -- s2))
?f :: (s.&Char -- s.&(s1 -- s2))
[ :: (s -- s)
?[ :: (s -- s)
?] :: (s -- s)
: :: (s -- s1)
' :: (s -- s.&(s1 -- s2))
immediate :: (s -- s)
literal :: (s.x1 -- s)
[compile] :: (s -- s)
['] :: (s -- s)
compile :: (s -- s)
tail :: (s -- s)
recurse :: (s -- s)
here :: (s -- s.&c1)
ahead> :: (s -- s.&c1)
<patch :: (s.&Num -- s)
if :: (s -- s.&c1)
then :: (s.&Num -- s)
else :: (s.&Num -- s.&c1)
begin :: (s -- s.&c1)
again :: (s.&c1 -- s)
bl :: (s -- s.Num)
is-white :: (s.Num -- s.Num)
skip-leading-whitespace :: (s -- s)
collect-while-not-whitespace :: (s -- s)
word, :: (s -- s.&c1)
word :: (s -- s.&c1)
char :: (s -- s.Num)
[char] :: (s -- s)
skip-to-close :: (s.Num -- s)
( :: (s -- s)
2 :: (s -- s.Num)
3 :: (s -- s.Num)
constant :: (s.x1 -- s)
variable :: (s -- s)
type :: (s.&Char -- s)
collect-string :: (s -- s.Num)
s" :: (s -- s)
." :: (s -- s1)
abort" :: (s -- s1)
.." :: (s -- s1)
forth.f
space :: (s -- s)
rot :: (s.x1.x2.x3 -- s.x2.x4.x1)
-rot :: (s.x1.x2.x3 -- s.x3.x1.x4)
show-if-not-hidden :: (s.&(s1 -- s2) -- s)
words-continue :: (s.&(s1 -- s2).&(s1 -- s2) -- s.&(s1 -- s2).&(s1 -- s2))
words-since :: (s.&(s1 -- s2) -- s)
words :: (s -- s)
x-hide :: (s.&(s1 -- s2) -- s)
hide :: (s -- s)
allot :: (s.Num -- s)
cell :: (s -- s.Num)
cells :: (s.Num -- s.Num)
cell+ :: (s.x1 -- s.x1)
char+ :: (s.x1 -- s.x1)
chars :: (s -- s)
space :: (s -- s)
spaces :: (s.Num -- s)
false :: (s -- s.x1)
true :: (s -- s.Num)
or :: (s.Num.x1 -- s.Num)
and :: (s.x1.x2 -- s.x1)
invert :: (s.Num -- s.Num)
nip :: (s.x1.x2 -- s.x2)
2dup :: (s.x1.x2 -- s.x1.x2.x1.x2)
2drop :: (s.x1.x2 -- s)
> :: (s.x1.x1 -- s.Num)
<= :: (s.x1.x1 -- s.Num)
>= :: (s.x1.x1 -- s.Num)
0< :: (s.x1 -- s.Num)
0= :: (s.x1 -- s.Num)
1+ :: (s.x1 -- s.x1)
1- :: (s.Num -- s.Num)
negate :: (s.x1 -- s.Num)
abs :: (s.Num -- s.Num)
min :: (s.x1.x1 -- s.x1)
max :: (s.x1.x1 -- s.x1)
mod :: (s.Num.Num -- s.Num)
/ :: (s.Num.Num -- s.Num)
+! :: (s.Num.&Num -- s)
256 :: (s -- s.Num)
akey? :: (s -- s.Num)
ekey? :: (s -- s.Num)
do :: (s -- s.&c1)
i :: (s -- s)
loop :: (s.&c1 -- s)
erase :: (s.&Char.Num -- s)
2 :: (s -- s.Num)
10 :: (s -- s.Num)
16 :: (s -- s.Num)
256 :: (s -- s.Num)
hex-mode :: (s -- s.&c1)
hex :: (s -- s)
decimal :: (s -- s)
decimal-digit? :: (s.Num -- s.Num)
extended-digit? :: (s.Num -- s.Num)
hex-digit? :: (s.Num -- s.Num)
digit? :: (s.Num -- s.Num)
convert-digit :: (s.Num -- s.Num)
base :: (s -- s.Num)
